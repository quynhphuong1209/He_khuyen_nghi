# -*- coding: utf-8 -*-
"""Quỳnh Phương 3_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10oZPNIyrHZfNShMn3ngLNo0QWstBtCmn

# =============================
# BÀI TẬP 1: Mô hình cây quyết định cho hệ khuyến nghị
# =============================
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import confusion_matrix, roc_curve, auc
import matplotlib.pyplot as plt
import seaborn as sns
import os
import urllib.request
import zipfile

ml_100k_url = 'https://files.grouplens.org/datasets/movielens/ml-100k.zip'
ml_100k_zip = 'ml-100k.zip'
ml_100k_folder = 'ml-100k'

if not os.path.exists(ml_100k_folder):
    if not os.path.exists(ml_100k_zip):
        print('Downloading MovieLens 100K dataset...')
        urllib.request.urlretrieve(ml_100k_url, ml_100k_zip)
    print('Extracting MovieLens 100K dataset...')
    with zipfile.ZipFile(ml_100k_zip, 'r') as zip_ref:
        zip_ref.extractall('.')

# Đọc dữ liệu đánh giá
ratings_cols = ['userID', 'itemID', 'rating', 'timestamp']
ratings_df = pd.read_csv('ml-100k/u.data', sep='\t', names=ratings_cols, encoding='latin-1')

# Đọc thông tin người dùng
users_cols = ['user_id', 'age', 'gender', 'occupation', 'zip_code']
users = pd.read_csv('ml-100k/u.user', sep='|', names=users_cols, encoding='latin-1')

# Đọc thông tin phim
movies_cols = ['movie_id', 'title', 'release_date', 'video_release_date',
               'imdb_url', 'unknown', 'Action', 'Adventure', 'Animation',
               'Children', 'Comedy', 'Crime', 'Documentary', 'Drama', 'Fantasy',
               'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi',
               'Thriller', 'War', 'Western']
movies = pd.read_csv('ml-100k/u.item', sep='|', names=movies_cols, encoding='latin-1')

ratings_df.head()

users[users["user_id"] == 186]

movies[movies["movie_id"] == 243]

len(users.occupation.unique())

from google.colab import sheets
sheet = sheets.InteractiveSheet(df=ratings_df)

# TODO: Tiền xử lý dữ liệu
# 1. Chuyển đổi đặc trưng phân loại (gender, occupation) thành one-hot encoding
users_processed = users.copy()
users_processed = pd.get_dummies(users_processed, columns=['gender', 'occupation'])
users_processed[users_processed["user_id"] == 186]

# TODO: Tạo biến mục tiêu (thích/không thích)
# Tạo biến ratings_merged bằng cách nối các bảng
ratings_merged = pd.merge(ratings_df, users, left_on='userID', right_on='user_id')
ratings_merged = pd.merge(ratings_merged, movies, left_on='itemID', right_on='movie_id')

# Tạo cột mục tiêu 'liked' dựa trên rating
if 'rating' in ratings_merged.columns:
    ratings_merged['liked'] = (ratings_merged['rating'] >= 4).astype(int)
else:
    raise KeyError("⚠️ Không tìm thấy cột 'rating' trong ratings_merged để tạo cột 'liked'.")

# Kiểm tra
print("✅ Tạo xong cột 'liked'. Các cột hiện có:", ratings_merged.columns.tolist())
print("📊 Xem dữ liệu:")
print(ratings_merged[['userID', 'itemID', 'rating', 'liked']].head())

# TODO: Chia dữ liệu thành tập huấn luyện và tập kiểm tra
# One-hot encoding cho các cột phân loại trong users
users_encoded = pd.get_dummies(users[['user_id', 'age', 'gender', 'occupation']], columns=['gender', 'occupation'])

# Kết hợp users_encoded vào ratings_merged
ratings_merged = pd.merge(ratings_df, users_encoded, left_on='userID', right_on='user_id')
ratings_merged = pd.merge(ratings_merged, movies, left_on='itemID', right_on='movie_id')

# Tạo biến mục tiêu
ratings_merged['liked'] = (ratings_merged['rating'] >= 4).astype(int)

# Tạo biến mục tiêu
ratings_merged['liked'] = (ratings_merged['rating'] >= 4).astype(int)

# Xây dựng danh sách các biến đầu vào
feature_cols = ['age'] + list(users_encoded.columns.drop(['user_id'])) + [
    'unknown', 'Action', 'Adventure', 'Animation', 'Children', 'Comedy', 'Crime', 'Documentary',
    'Drama', 'Fantasy', 'Film-Noir', 'Horror', 'Musical', 'Mystery', 'Romance', 'Sci-Fi',
    'Thriller', 'War', 'Western'
]

# Kiểm tra xem các cột có đủ không
for col in feature_cols:
    if col not in ratings_merged.columns:
        raise KeyError(f"⚠️ Thiếu cột '{col}' trong ratings_merged. Kiểm tra lại việc merge hoặc xử lý dữ liệu.")

# Tách dữ liệu
X = ratings_merged[feature_cols]
y = ratings_merged['liked']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("📋 Xem bảng ratings_merged (sau khi merge và thêm 'liked'):")
display(ratings_merged.head())

print("🧾 Các đặc trưng (X):")
display(X.head())

print("✅ Nhãn mục tiêu (y):")
display(y.head())

print("🔹 X_train:")
display(X_train.head())

print("🔸 y_train:")
display(y_train.head())

# TODO: Xây dựng và huấn luyện mô hình cây quyết định
clf = DecisionTreeClassifier(max_depth=5, random_state=42)
clf.fit(X_train, y_train)

# TODO: Đánh giá hiệu suất mô hình
y_pred = clf.predict(X_test)
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Precision:", precision_score(y_test, y_pred))
print("Recall:", recall_score(y_test, y_pred))
print("F1 Score:", f1_score(y_test, y_pred))

# Ma trận nhầm lẫn
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.show()

# ROC Curve
y_prob = clf.predict_proba(X_test)[:, 1]
fpr, tpr, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(fpr, tpr)

plt.plot(fpr, tpr, label=f"AUC = {roc_auc:.2f}")
plt.plot([0, 1], [0, 1], 'k--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve")
plt.legend()
plt.show()

# TODO: Trực quan hóa cây quyết định và phân tích đặc trưng quan trọng
plt.figure(figsize=(20, 10))
plot_tree(clf, feature_names=feature_cols, class_names=['Not Liked', 'Liked'], filled=True, rounded=True)
plt.title("Decision Tree")
plt.show()

importances = pd.Series(clf.feature_importances_, index=feature_cols).sort_values(ascending=False)
plt.figure(figsize=(10, 6))
sns.barplot(x=importances.values, y=importances.index)
plt.title("Feature Importances")
plt.xlabel("Importance Score")
plt.show()